<!-- loading.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liquid Loading</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a4d68 0%, #088395 50%, #05bfdb 100%);
            font-family: system-ui, -apple-system, sans-serif;
            position: relative;
            overflow: hidden;
        }
        
        .stars {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transition: opacity 0.8s ease-out;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 30px;
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        canvas#liquidCanvas {
            display: block;
            filter: drop-shadow(0 15px 35px rgba(0, 0, 0, 0.4));
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* Transition overlay */
        .transition-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #0a4d68 0%, #000000 100%);
            opacity: 0;
            pointer-events: none;
            z-index: 1000;
            transition: opacity 1.2s ease-in-out;
        }
        
        .transition-overlay.active {
            opacity: 1;
        }
        
        /* Fade out animations */
        body.transitioning .stars {
            opacity: 0;
        }
        
        body.transitioning .container {
            transform: scale(1.15);
            opacity: 0;
        }
        
        body.transitioning canvas#liquidCanvas {
            filter: drop-shadow(0 30px 60px rgba(0, 0, 0, 0.6)) blur(2px);
        }
    </style>
</head>
<body>
    <div class="transition-overlay" id="transitionOverlay"></div>
    <canvas class="stars" id="starsCanvas"></canvas>
    <div class="container">
        <canvas id="liquidCanvas" width="350" height="350"></canvas>
    </div>

    <script>
        // Load the logo image
        const logoImg = new Image();
        logoImg.src = 'assets/icons/logo.png';
        
        // Stars background
        const starsCanvas = document.getElementById('starsCanvas');
        const starsCtx = starsCanvas.getContext('2d');
        starsCanvas.width = window.innerWidth;
        starsCanvas.height = window.innerHeight;
        
        const stars = [];
        const numStars = 80;
        
        for (let i = 0; i < numStars; i++) {
            stars.push({
                x: Math.random() * starsCanvas.width,
                y: Math.random() * starsCanvas.height,
                size: Math.random() * 2 + 1,
                opacity: Math.random() * 0.5 + 0.5,
                twinkleSpeed: Math.random() * 0.008 + 0.004,
                driftX: (Math.random() - 0.5) * 0.1,
                driftY: (Math.random() - 0.5) * 0.05,
                color: Math.random() > 0.3 ? 'white' : 'black'
            });
        }
        
        function drawStars() {
            starsCtx.clearRect(0, 0, starsCanvas.width, starsCanvas.height);
            
            stars.forEach(star => {
                // Gentle drifting motion
                star.x += star.driftX;
                star.y += star.driftY;
                
                // Wrap around screen
                if (star.x < 0) star.x = starsCanvas.width;
                if (star.x > starsCanvas.width) star.x = 0;
                if (star.y < 0) star.y = starsCanvas.height;
                if (star.y > starsCanvas.height) star.y = 0;
                
                // Smooth twinkling
                star.opacity += star.twinkleSpeed;
                if (star.opacity > 1 || star.opacity < 0.2) {
                    star.twinkleSpeed *= -1;
                }
                
                starsCtx.save();
                starsCtx.translate(star.x, star.y);
                
                starsCtx.fillStyle = star.color === 'white' 
                    ? `rgba(255, 255, 255, ${star.opacity})` 
                    : `rgba(0, 0, 0, ${star.opacity * 0.7})`;
                
                // Draw sparkle shape
                starsCtx.beginPath();
                starsCtx.moveTo(0, -star.size);
                starsCtx.lineTo(star.size * 0.3, 0);
                starsCtx.lineTo(0, star.size);
                starsCtx.lineTo(-star.size * 0.3, 0);
                starsCtx.closePath();
                starsCtx.fill();
                
                starsCtx.beginPath();
                starsCtx.moveTo(-star.size, 0);
                starsCtx.lineTo(-star.size * 0.3, star.size * 0.2);
                starsCtx.lineTo(star.size * 0.3, star.size * 0.2);
                starsCtx.lineTo(star.size, 0);
                starsCtx.lineTo(star.size * 0.3, -star.size * 0.2);
                starsCtx.lineTo(-star.size * 0.3, -star.size * 0.2);
                starsCtx.closePath();
                starsCtx.fill();
                
                // Smooth glow
                if (star.opacity > 0.7) {
                    const glowSize = star.size * 2.5;
                    const gradient = starsCtx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
                    gradient.addColorStop(0, star.color === 'white' 
                        ? `rgba(255, 255, 255, ${(star.opacity - 0.7) * 0.4})` 
                        : `rgba(0, 0, 0, ${(star.opacity - 0.7) * 0.3})`);
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    starsCtx.fillStyle = gradient;
                    starsCtx.beginPath();
                    starsCtx.arc(0, 0, glowSize, 0, Math.PI * 2);
                    starsCtx.fill();
                }
                
                starsCtx.restore();
            });
        }
        
        // Main liquid animation
        const canvas = document.getElementById('liquidCanvas');
        const ctx = canvas.getContext('2d');
        
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = 150;
        
        let progress = 0;
        let time = 0;
        let transitionStarted = false;
        
        // Enhanced wave parameters with smoother motion
        const waves = [
            { amp: 10, freq: 0.016, speed: 0.022, phase: 0, chaos: 0.25 },
            { amp: 7, freq: 0.028, speed: 0.029, phase: Math.PI / 3, chaos: 0.4 },
            { amp: 12, freq: 0.019, speed: 0.025, phase: Math.PI / 1.5, chaos: 0.3 },
            { amp: 6, freq: 0.038, speed: 0.035, phase: Math.PI, chaos: 0.5 },
            { amp: 9, freq: 0.022, speed: 0.031, phase: Math.PI / 6, chaos: 0.28 },
            { amp: 5, freq: 0.042, speed: 0.027, phase: Math.PI * 1.3, chaos: 0.42 },
            { amp: 8, freq: 0.033, speed: 0.033, phase: Math.PI / 4, chaos: 0.38 }
        ];
        
        function calculateWaveOffset(x, t, layerOffset = 0) {
            let offset = 0;
            
            // Gradually reduce wave amplitude as we approach 100%
            const waveDamping = progress > 95 ? Math.max(0, (100 - progress) / 5) : 1;
            
            waves.forEach((wave, i) => {
                const chaosValue = Math.sin(t * 0.012 * (i + 1) + x * 0.006) * wave.chaos;
                const waveValue = Math.sin(x * wave.freq + t * wave.speed + wave.phase + layerOffset + chaosValue);
                offset += waveValue * wave.amp * waveDamping;
            });
            
            // Perlin-like smooth noise
            offset += Math.sin(t * 0.015 + x * 0.01) * 3.5 * waveDamping;
            offset += Math.cos(t * 0.019 + x * 0.014) * 2.5 * waveDamping;
            offset += Math.sin(t * 0.023 + x * 0.008) * 1.5 * waveDamping;
            
            return offset;
        }
        
        function drawLiquid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Animated outer glow that pulses gently
            const glowPulse = Math.sin(time * 0.02) * 0.05 + 0.95;
            const glowGradient = ctx.createRadialGradient(centerX, centerY, radius - 10, centerX, centerY, radius + 25);
            glowGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
            glowGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0)');
            glowGradient.addColorStop(1, `rgba(255, 255, 255, ${0.2 * glowPulse})`);
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius + 25, 0, Math.PI * 2);
            ctx.fill();
            
            // White circle background
            ctx.fillStyle = '#f8f9fa';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Dynamic inner shadow
            const shadowGradient = ctx.createRadialGradient(centerX, centerY, radius - 20, centerX, centerY, radius);
            shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0.12)');
            ctx.fillStyle = shadowGradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Calculate liquid fill level with smooth easing
            const fillHeight = (progress / 100) * (radius * 2);
            const liquidBottom = centerY + radius;
            const liquidTop = liquidBottom - fillHeight;
            
            // Create clipping circle
            ctx.save();
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius - 2, 0, Math.PI * 2);
            ctx.clip();
            
            // Darker gradient with smooth transitions
            const liquidGradient = ctx.createLinearGradient(0, liquidBottom, 0, liquidTop);
            const gradientProgress = Math.min(progress / 100, 1);
            
            liquidGradient.addColorStop(0, `rgba(35, 35, 35, ${0.85 + gradientProgress * 0.15})`);
            liquidGradient.addColorStop(0.25, `rgba(25, 25, 25, ${0.9 + gradientProgress * 0.1})`);
            liquidGradient.addColorStop(0.5, `rgba(15, 15, 15, ${0.95 + gradientProgress * 0.05})`);
            liquidGradient.addColorStop(0.75, `rgba(8, 8, 8, ${0.98 + gradientProgress * 0.02})`);
            liquidGradient.addColorStop(1, `rgba(0, 0, 0, 1)`);
            
            const startX = centerX - radius;
            const resolution = 0.8;
            
            // Draw main liquid
            ctx.fillStyle = liquidGradient;
            ctx.beginPath();
            ctx.moveTo(startX, liquidBottom);
            ctx.lineTo(centerX + radius, liquidBottom);
            ctx.lineTo(centerX + radius, liquidTop);
            
            // Always draw waves, but they'll be dampened near 100%
            for (let x = centerX + radius; x >= startX; x -= resolution) {
                const waveOffset = calculateWaveOffset(x, time);
                const y = liquidTop + waveOffset;
                ctx.lineTo(x, y);
            }
            
            ctx.lineTo(startX, liquidBottom);
            ctx.closePath();
            ctx.fill();
            
            // Multiple smooth wave layers - with dampening
            const waveDamping = progress > 95 ? Math.max(0, (100 - progress) / 5) : 1;
            
            if (progress > 3 && waveDamping > 0.1) {
                // Layer 1: Brightest surface shimmer
                ctx.fillStyle = `rgba(200, 200, 200, ${0.22 * waveDamping})`;
                ctx.beginPath();
                
                for (let x = centerX + radius; x >= startX; x -= resolution) {
                    const waveOffset = calculateWaveOffset(x, time, 0.4) * 0.92;
                    const y = liquidTop + waveOffset - 6;
                    if (x === centerX + radius) ctx.moveTo(x, y);
                    ctx.lineTo(x, y);
                }
                
                for (let x = startX; x <= centerX + radius; x += resolution) {
                    const waveOffset = calculateWaveOffset(x, time, 0.4) * 0.92;
                    const y = liquidTop + waveOffset + 10;
                    ctx.lineTo(x, y);
                }
                
                ctx.closePath();
                ctx.fill();
            }
            
            if (progress > 8 && waveDamping > 0.1) {
                // Layer 2: Mid-tone depth
                ctx.fillStyle = `rgba(140, 140, 140, ${0.16 * waveDamping})`;
                ctx.beginPath();
                
                for (let x = centerX + radius; x >= startX; x -= resolution) {
                    const waveOffset = calculateWaveOffset(x + 60, time * 1.25, 1.1) * 0.72;
                    const y = liquidTop + waveOffset + 8;
                    if (x === centerX + radius) ctx.moveTo(x, y);
                    ctx.lineTo(x, y);
                }
                
                for (let x = startX; x <= centerX + radius; x += resolution) {
                    const waveOffset = calculateWaveOffset(x + 60, time * 1.25, 1.1) * 0.72;
                    const y = liquidTop + waveOffset + 24;
                    ctx.lineTo(x, y);
                }
                
                ctx.closePath();
                ctx.fill();
            }
            
            if (progress > 15 && waveDamping > 0.1) {
                // Layer 3: Deep subsurface
                ctx.fillStyle = `rgba(80, 80, 80, ${0.12 * waveDamping})`;
                ctx.beginPath();
                
                for (let x = centerX + radius; x >= startX; x -= resolution) {
                    const waveOffset = calculateWaveOffset(x - 40, time * 0.82, 1.9) * 0.58;
                    const y = liquidTop + waveOffset + 18;
                    if (x === centerX + radius) ctx.moveTo(x, y);
                    ctx.lineTo(x, y);
                }
                
                for (let x = startX; x <= centerX + radius; x += resolution) {
                    const waveOffset = calculateWaveOffset(x - 40, time * 0.82, 1.9) * 0.58;
                    const y = liquidTop + waveOffset + 32;
                    ctx.lineTo(x, y);
                }
                
                ctx.closePath();
                ctx.fill();
            }
            
            if (progress > 10 && waveDamping > 0.1) {
                // Layer 4: Highlight accents
                ctx.fillStyle = `rgba(220, 220, 220, ${0.18 * waveDamping})`;
                ctx.beginPath();
                
                for (let x = centerX + radius; x >= startX; x -= resolution * 1.5) {
                    const waveOffset = calculateWaveOffset(x + 90, time * 1.42, 0.7) * 0.88;
                    const y = liquidTop + waveOffset - 4;
                    if (x === centerX + radius) ctx.moveTo(x, y);
                    ctx.lineTo(x, y);
                }
                
                for (let x = startX; x <= centerX + radius; x += resolution * 1.5) {
                    const waveOffset = calculateWaveOffset(x + 90, time * 1.42, 0.7) * 0.88;
                    const y = liquidTop + waveOffset + 7;
                    ctx.lineTo(x, y);
                }
                
                ctx.closePath();
                ctx.fill();
            }
            
            // Floating light reflections with smooth motion
            if (progress > 20 && progress < 94) {
                const reflection1X = centerX + Math.sin(time * 0.018) * 40;
                const reflection1Y = liquidTop + Math.cos(time * 0.022) * 12;
                
                const spotGradient1 = ctx.createRadialGradient(reflection1X, reflection1Y, 0, reflection1X, reflection1Y, 50);
                spotGradient1.addColorStop(0, 'rgba(220, 220, 220, 0.18)');
                spotGradient1.addColorStop(0.5, 'rgba(160, 160, 160, 0.08)');
                spotGradient1.addColorStop(1, 'rgba(100, 100, 100, 0)');
                
                ctx.fillStyle = spotGradient1;
                ctx.beginPath();
                ctx.arc(reflection1X, reflection1Y, 50, 0, Math.PI * 2);
                ctx.fill();
                
                const reflection2X = centerX - Math.sin(time * 0.024) * 45;
                const reflection2Y = liquidTop + Math.sin(time * 0.019) * 14;
                
                const spotGradient2 = ctx.createRadialGradient(reflection2X, reflection2Y, 0, reflection2X, reflection2Y, 40);
                spotGradient2.addColorStop(0, 'rgba(200, 200, 200, 0.14)');
                spotGradient2.addColorStop(0.6, 'rgba(140, 140, 140, 0.06)');
                spotGradient2.addColorStop(1, 'rgba(90, 90, 90, 0)');
                
                ctx.fillStyle = spotGradient2;
                ctx.beginPath();
                ctx.arc(reflection2X, reflection2Y, 40, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
            
            // Draw logo in front of waves with aspect ratio maintained
            if (logoImg.complete) {
                // Calculate size to match circle's height while maintaining aspect ratio
                const circleHeight = radius * 2;
                const logoAspectRatio = logoImg.width / logoImg.height;
                const logoHeight = circleHeight * 0.775;
                const logoWidth = logoHeight * logoAspectRatio;
                
                const logoX = centerX - logoWidth / 2;
                const logoY = centerY - logoHeight / 2;
                
                ctx.save();
                
                // Clip to circle
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius - 2, 0, Math.PI * 2);
                ctx.clip();
                
                // Calculate liquid level
                const fillHeight = (progress / 100) * (radius * 2);
                const liquidBottom = centerY + radius;
                const liquidTop = liquidBottom - fillHeight;
                
                // Draw the part of logo that's NOT filled (stays black)
                ctx.save();
                ctx.beginPath();
                ctx.rect(0, 0, canvas.width, liquidTop + 30);
                ctx.clip();
                ctx.drawImage(logoImg, logoX, logoY, logoWidth, logoHeight);
                ctx.restore();
                
                // Draw the part of logo that IS filled (turns white)
                if (progress > 0) {
                    ctx.save();
                    
                    // Create clipping path for filled area with waves
                    ctx.beginPath();
                    const startX = centerX - radius;
                    const resolution = 0.8;
                    
                    ctx.moveTo(startX, liquidBottom);
                    ctx.lineTo(centerX + radius, liquidBottom);
                    ctx.lineTo(centerX + radius, liquidTop);
                    
                    for (let x = centerX + radius; x >= startX; x -= resolution) {
                        const waveOffset = calculateWaveOffset(x, time);
                        const y = liquidTop + waveOffset;
                        ctx.lineTo(x, y);
                    }
                    
                    ctx.lineTo(startX, liquidBottom);
                    ctx.closePath();
                    ctx.clip();
                    
                    // Draw white version of logo
                    ctx.filter = 'invert(1) brightness(2)';
                    ctx.drawImage(logoImg, logoX, logoY, logoWidth, logoHeight);
                    ctx.filter = 'none';
                    
                    ctx.restore();
                }
                
                ctx.restore();
            }
            
            // Subtle border
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        function startTransition() {
            if (transitionStarted) return;
            transitionStarted = true;
            
            // Add transitioning class to body
            document.body.classList.add('transitioning');
            
            // Activate overlay
            const overlay = document.getElementById('transitionOverlay');
            overlay.classList.add('active');
            
            // Wait for transition to complete, then navigate or load content
            setTimeout(() => {
                // Replace this with your actual page navigation
                // window.location.href = 'your-main-page.html';
                
                // For demo purposes, just reload
                // window.location.reload();
                
                console.log('Transition complete - navigate to main page here');
            }, 1200);
        }
        
        function animate() {
            time += 1;
            
            // Smooth progress with slight easing
            if (progress < 100) {
                progress += 0.18;
                if (progress > 100) progress = 100;
            } else if (progress >= 100 && !transitionStarted) {
                // Wait a moment at 100% before transitioning
                setTimeout(() => {
                    startTransition();
                }, 600);
            }
            
            drawStars();
            drawLiquid();
            requestAnimationFrame(animate);
        }
        
        animate();
    </script>
<!-- Loading Connector Script -->
    <script src="./js/loading-connector.js"></script>
    <script>
      // Initialize connector
      const connector = new window.LoadingConnector();
      
      // Start simulating progress
      const progressInterval = connector.simulateProgress();
      
      // Simulate actual asset loading time
      setTimeout(() => {
        clearInterval(progressInterval);
        connector.complete();
      }, 3000); // Adjust this to match your actual loading time
    </script>
  </body>
</html>